import json
import pandas as pd
import numpy as np
import pathlib
from pathlib import Path as path
from typing import Tuple, Union
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator



class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        self.data_fname = pathlib.Path(data_fname) 
        if not self.data_fname.exists():
            raise ValueError(f"File does not exist: {self.data_fname}")
        self.data = None


    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        if not self.data_fname.exists():
            raise FileNotFoundError(f"Data file {self.data_fname} does not exist.")
        
        with open(self.data_fname, 'r', encoding='utf-8') as f:
            self.data = json.load(f)
         
        if not isinstance(self.data, list):
            raise ValueError("Expected a list of participant dictionaries.")
        
        if not all(isinstance(item, dict) for item in self.data):
            raise ValueError("Each participant record should be a dictionary.")
        
        # convert to DataFrame for easier manipulation later
        self.data = pd.DataFrame(self.data) 
        print(f"Data loaded successfully. Number of participants: {len(self.data)}")
        return self.data
       

    def _extract_ages(self) -> list:
        ages = []
        for _, row in self.data.iterrows():
            age = row["age"]
            if pd.isna(age) or str(age).lower() == "nan":
                continue
            try:
                ages.append(int(age))
            except (ValueError, TypeError):
                continue
        return ages

    
    
    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

        Returns
        -------
        hist : np.ndarray
        Number of people in a given bin
        bins : np.ndarray
        Bin edges
        """
        q = self
        q.read_data()                  
        ages = q._extract_ages()       # Extract ages from data
        
        if not ages:
            raise ValueError("No ages found in the data.")
        
        hist, bins = np.histogram(ages, bins=10, range=(0, 100))
        plt.figure(figsize=(10, 6))
        plt.bar(bins[:-1], hist, width=np.diff(bins), edgecolor='black', align='edge')
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.title('Age Distribution of Participants')
        plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.show()
        return hist, bins
    

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

        Returns
        -------
        df : pd.DataFrame
        A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
        the (ordinal) index after a reset.
        """
        def is_valid_email(email: str) -> bool:
            """Check if the email is valid."""
            return (
                isinstance(email, str) and                              # Must be a string
                email.count('@') == 1 and                               # Exactly one @
                not (email.startswith('@') or email.endswith('@')) and  # Must not start or end with @
                '.' in email and                                        # Must contain a dot
                not (email.startswith('.') or email.endswith('.')) and  # Must not start or end with a dot
                email[email.index('@') + 1] != '.'                      # No dot immediately after @
            )

        # Create a list to hold valid participants
        clean = self.data['email'].apply(is_valid_email)  
        # Filter the data to keep only valid emails
        df = self.data[clean].copy().reset_index(drop=True) 
        
        print(f"Removed rows with invalid emails. Remaining participants: {len(df)}")
        # print a list of the remaiming emails
        print("Remaining valid emails:")
        for email in df['email'].tolist():
            print(email)
        
        return df
  

            
    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
        df : pd.DataFrame
        The corrected DataFrame after insertion of the mean grade
        arr : np.ndarray
        Row indices of the students that their new grades were generated
        """
        df = self.data.copy()
        grade_cols = ["q1", "q2", "q3", "q4", "q5"]

        # Ensure grades are numeric
        df[grade_cols] = df[grade_cols].apply(pd.to_numeric, errors='coerce')
        df[grade_cols] = df[grade_cols].astype('float64')


        # Track which rows are affected
        updated_indices = []

        # Process each row
        for idx, row in df.iterrows():
            mask = row[grade_cols].isnull()
            if mask.any():
                values = row[grade_cols][~mask]
                mean = values.mean()
                df.loc[idx, mask.index[mask]] = mean
                updated_indices.append(idx)

        print(f"Filled missing grades with mean. Updated DataFrame has {len(df)} participants.")
        print(f"Indices of updated participants: {updated_indices}")

        return df, np.array(updated_indices)
    



    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates average score and adds a 'score' column with rules for missing data."""
        
        # Create a copy of the data to avoid modifying self.data directly
        df = self.data.copy()
        
        # Initialize a new column for scores
        scores = []

        # Iterate through each perticipant to calculate their score
        for idx, row in df.iterrows():
            grades = [row["q1"], row["q2"], row["q3"], row["q4"], row["q5"]]

            # Convert invalid entries to NaN
            grades = [
                g if (g is not None and str(g).lower() != "nan") else np.nan
                for g in grades
            ]
            # Count NaN values in the grades
            nan_count = np.count_nonzero(np.isnan(grades))
            
            # If there are too many NaNs, set score to NaN
            if nan_count > maximal_nans_per_sub:
                scores.append(np.nan)
            else:
                mean_score = np.nanmean(grades)
                scores.append(np.floor(mean_score).astype(np.uint8))

        # Assign new score column with nullable int type
        df["score"] = pd.Series(scores, dtype=pd.UInt8Dtype())
    
        # print a list of the scores
        print("Scores for each participant:")
        for idx, score in enumerate(scores):
            print(f"Participant {idx + 1}: Score = {score}")
    
        return df
    

    def correlate_gender_age(self) -> pd.DataFrame:
        """Looks for a correlation between the gender of the subject, their age
        and the score for all five questions.

        Returns
        -------
        pd.DataFrame
            A DataFrame with a MultiIndex containing the gender and whether the subject is above
            40 years of age, and the average score in each of the five questions.
        """
        df = self.data.copy()

        # Convert 'age' to numeric
        df['age'] = pd.to_numeric(df['age'], errors='coerce')

        # Drop rows with missing gender or age
        df = df.dropna(subset=['gender', 'age'])

        # Create age group: True if age > 40
        df['age'] = df['age'] > 40

        # Use only the known question columns
        question_cols = ['q1', 'q2', 'q3', 'q4', 'q5']

        # Turn columns to numeric, coercing errors to NaN
        df[question_cols] = df[question_cols].apply(pd.to_numeric, errors='coerce')

        # Group by gender and age group and compute the mean while ignoring NaNs
        grouped = df.groupby(['gender', 'age'])[question_cols].mean()

        # Make sure index levels are named correctly
        grouped.index.set_names(['gender', 'age'], inplace=True)
        
        print(grouped)

        return grouped